#결론

콜백 함수는 다른 함수에 인수로 전달되는 함수이며, 일종의 루틴이나 작업을 완료한다.
주로 비동기 처리를 위해 사용되었는데 콜백 함수 호출이 중복되어 복잡도가 높아지는 콜백헬 현상, 에러 처리의 한계의 문제를 가져
그를 극복하기 위핸 Promise가 ES6에 도입되었다.

#설명

콜백 함수는 다른 함수에 인수로 전달되는 함수이며 외부 함수 내부에서 호출되어 일종의 루틴이나 작업을 완료한다.

비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않아도 비동기 함수는 즉시 종료되기 때문에
비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부에 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.
그래서 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 비동기 함수에 전달하는 것이 일반적이었다.

- 문제점

1. 콜백헬
그런데, 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 
비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중복되어 복잡도가 높아지는 현상이 발생한다.

```
get('/step1',a=>{
  get('/step2/${a}`, b => {
    get('/step3/${b}`, c => {
      get('/step4/${c}`, d => {
      	console.log(d);
		});
	});
  });
});
```
위와 같은 콜백 헬이 발생할 수 있다.

2. 에러 처리의 한계

```
try {
	setTimeout(() => {throw new Error('Error');},1000);
} catch (e) {
    //에러를 캐치하지 못한다.
	console.error('캐치한 에러',e); 
}
```
try 내의 setTimeout 함수는 1초 후에 콜백 함수가 실행되도록 타이머를 설정하고, 이후 콜백 함수는 에러를 발생시킨다. 
하지만 catch에서는 에러를 캐치하지 못한다.

setTimeout은 비동기 함수이기에 콜백 함수가 호출되는 것을 기다리지 않고 종료되어 콜스택에서 제거된다.
결국 setTimeout 함수의 콜백함수는 setTimeout함수가 아닌 이벤트 루프에 의해 콜스택으로 푸쉬되어 실행되는데
에러는 호출자 방향으로 전파되기에 setTimeout 함수의 콜백 함수가 발생시킨 에러는 catch블록에서 캐치되지 않는다.

이러한 문제들을 극복하기 위해 ES6에서 프로미스가 도입되었다.


#references 

https://developer.mozilla.org/en-US/docs/Glossary/Callback_function
